- name: indent if else end statement
  input: |
    if foo
    bar = 1
    elsif foo2
    bar = 2
    else
    bar = 3
    end
  output: |
    if foo
      bar = 1
    elsif foo2
      bar = 2
    else
      bar = 3
    end

- name: handle case where if begins and ends on same line
  input: |
    foo do
    if a then b = 1 else b = 2 end
    end
  output: |
    foo do
      if a then b = 1 else b = 2 end
    end

- name: indent case when statement
  input: |
    case foo
    when 1
    bar = 'some string'
    when 2
    bar = 'some other string'
    when 3 then bar = '3'
    else
    bar = '4'
    end
  output: |
    case foo
      when 1
        bar = 'some string'
      when 2
        bar = 'some other string'
      when 3 then bar = '3'
      else
        bar = '4'
    end

- name: ignore code after end of line comment
  input: |
    def method_containing_end_of_line_comment
    a = b # Comment containing do
    end
  output: |
    def method_containing_end_of_line_comment
      a = b # Comment containing do
    end

- name :not indent multineline comment:
  input: |
    =begin
    Comment
    =end
    foo

- name: indent lines after first of multiline code
  input: |
    def method_with_multiline_method_call
    multiline_method_call \
    first_arg,
    second_arg,
    third_arg
    end
  output: |
    def method_with_multiline_method_call
      multiline_method_call \
        first_arg,
        second_arg,
        third_arg
    end

- name: indent method call with bracketed multiline arguments
  input: |
    def method_with_multiline_method_call
    multiline_method_call(foo,
    bar,
    foobar)
    end
  output: |
    def method_with_multiline_method_call
      multiline_method_call(foo,
                            bar,
                            foobar)
    end

- name: indent method call with bracketed multiline arguments_even_if_not_first_block_on_line
  input: |
    if (foo = bar(first_arg,
    second_arg))
    do_something
    end
  output: |
    if (foo = bar(first_arg,
                  second_arg))
      do_something
    end

- name: indent method call with multiline arguments (implicit brackets)
  input: |
    def method_with_multiline_method_call
    multiline_method_call first_arg,
    second_arg,
    # Comment in the middle of all this
    third_arg
    
    another_method_call
    end
  output: |
    def method_with_multiline_method_call
      multiline_method_call first_arg,
        second_arg,
        # Comment in the middle of all this
        third_arg
    
      another_method_call
    end

- name: should indent multiline method call chains
  input: |
    def method_with_multiline_method_call_chain
    multiline_method_call.
    foo.
    bar
    
    another_method_call
    end
  output: |
    def method_with_multiline_method_call_chain
      multiline_method_call.
        foo.
        bar
    
      another_method_call
    end

- name: handle multiline code with escaped quotes in strings
  input: |
    def method_containing_multiline_code_with_strings
    a = "foo #{method}" +
    "bar"
    end
  output: |
    def method_containing_multiline_code_with_strings
      a = "foo #{method}" +
        "bar"
    end

- name: not change the indentation of multiline strings
  input: |
    def method_containing_long_string
    a = "
          Some text across multiple lines
          And another line
          "
    b = 5
    end
  output: |
    def method_containing_long_string
      a = "
          Some text across multiple lines
          And another line
          "
      b = 5
    end

- name: end indentation of implicit blocks when another implicit block starts or when surrounding block ends
  input: |
    class Foo
    private
    def method
    b = 5
    end
    protected
    def another_method
    c = 5
    end
    end
  output: |
    class Foo
      private
        def method
          b = 5
        end
      protected
        def another_method
          c = 5
        end
    end

- name: not treat divison as start of regex
  input: |
    def foo
    a = 1/2
    b = :foo
    end
  output: |
    def foo
      a = 1/2
      b = :foo
    end

- name: not indent multiline string even if it uses non quote delimiter
  pending: implementation of block matcher for non quote delimited strings
  input: |
    foo = <<TEXT
          some string
          and more string
    TEXT

- name: recognize when two blocks end on the same line
  input: |
    class Foo
    def foobar
    if a = 3
    return 5
    end; end
    end
  output: |
    class Foo
      def foobar
        if a = 3
          return 5
      end; end
    end

- name: indent multiline array definition
  input: |
    class Foo
    @@bar = [1, 2,
    3, 4]
    end
  output: |
    class Foo
      @@bar = [1, 2,
               3, 4]
    end

- name: indent multiline array definition (all on separate lines)
  input: |
    class Foo
    @@bar = [
    1,
    2,
    3,
    4
    ]
    end
  output: |
    class Foo
      @@bar = [
        1,
        2,
        3,
        4
      ]
    end

- name: indent multiline hash definition
  input: |
    class Foo
    @@bar = { :foo => 1, :bar => 2
    :c => 3, :d => 4 }
    end
  output: |
    class Foo
      @@bar = { :foo => 1, :bar => 2
                :c => 3, :d => 4 }
    end

